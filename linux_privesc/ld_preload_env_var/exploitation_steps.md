## Exploiting persisted LD_LIBRARY environment variable with sudo permissions ##
# If 'sudo -l' shows that LD_LIBRARY persists through the sudo environment
# and there are commands that can be run as sudo, try this exploit

# First compile the preload.c file as a shared library and store in /tmp/ as /tmp/preload.so
# This is going to create a library to be run before everything else (LD_LIBRARY=/tmp/preload.c)
    gcc -fPIC -shared -nostartfiles -o /tmp/preload.so /home/user/tools/sudo/preload.c

# The compiled shared library contains a shell script that spawns a root bash shell
# The next step is to run sudo, specify the compiled .so file as the library to run first and then
# use one of the programs that the user is allowed to run as root, in order for everything to take place
# within an elevated privilege environment
    sudo LD_PRELOAD=/tmp/preload.so <program>

## Exploiting persisted LD_LIBRARY_PATH environment variable with sudo permissions ##
# Same rules apply as above, LD_LIBRARY_PATH must be set as env_keep and at least one sudo privileged program

# Similar mechanisms run with a LD_LIBRARY_PATH exploit
# But, instead of an LD_PRELOAD library being replaced with malicious code
# the computer is being told to search a particular directory, for a shared library,
# where a malicious script, of the same name as a legitimate shared library, will be
# executed.

# Step one is to list the shared libraries that the computer will be told to search for
    ldd /usr/sbin/apache2

# Step two is to compile a malicious script, with the name of one of the shared libraries
# that LD_LIBRARY_PATH is being told to search for
    gcc -o /tmp/shared_lib_example.so -shared -fPIC library_path.c

# Final step is to exploit with:
    sudo LD_LIBRARY_PATH=/tmp <program>

# The reason the apache2 binary was used is because apache2 doesn't drop privileges
# early like other programs like nmap, ftp and man